{
  "hash": "069ad50fc7a8254c2830c05f051b9db6",
  "result": {
    "markdown": "---\ntitle: Portfolio Possibilities Curve (PPC)\ndescription: PPC with GPT4 as my coding partner\nauthor: David Harper, CFA, FRM\ndate: 2023-11-19\ncategories: [code, analysis]\nexecute: \n  echo: true\n  warning: false\n---\n\n\nContents\n\n-   Define the sets of stocks/indices\n-   Retrieve returns for each periodicity\n-   Analyze: add the analysis list column\n-   Setup the simulation\n-   Run the simulation\n-   Visualize\n\nload libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidyquant)\n# library(dplyr); library(tidyr); library(purrr)\n# library(ggplot)\n```\n:::\n\n\n## Define the SETS of stocks/indices\n\nThe container in this approach is **stock_sets**, a dataframe the we initialize (our TOC) with three columns:\n\n-   set_id\n-   description\n-   symbols: a list of tickers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsector_3eft_list <- c( \"XLK\", \"XLV\", \"XLP\") # Tech, Health, Staples\n# sector_4etf_list <- c( \"XLK\", \"XLV\", \"XLP\",  \"XLE\",) # Tech, Health, Staples, Energy\nsector_5etf_list <- c( \"XLK\", \"XLV\", \"XLP\", \"XLE\", \"XLF\") # Tech, Health, Staples, Energy, Financials\n# sector_7etf_list <- c(sector_5etf_list, \"XLI\", \"XLU\")\nsector_11etf_list <- c(\"XLK\",  # Technology\n                      \"XLV\",  # Health Care\n                      \"XLF\",  # Financials\n                      \"XLY\",  # Consumer Discretionary\n                      \"XLP\",  # Consumer Staples\n                      \"XLE\",  # Energy\n                      \"XLU\",  # Utilities\n                      \"XLI\",  # Industrials\n                      \"XLB\",  # Materials\n                      \"XLRE\", # Real Estate\n                      \"XLC\") # Communication Services\n\nsize_etfs <- c(\"SPY\", \"MDY\", \"IWM\") # Large, Mid, Small\n# size_style_etfs <- c(\"IWF\",  # Large-Cap Growth\n#                      \"IWD\",  # Large-Cap Value\n#                      \"SPY\",  # Large-Cap Blend\n#                      \"IWP\",  # Mid-Cap Growth\n#                      \"IWS\",  # Mid-Cap Value\n#                      \"MDY\",  # Mid-Cap Blend\n#                      \"IWO\",  # Small-Cap Growth\n#                      \"IWN\",  # Small-Cap Value\n#                      \"IWM\")  # Small-Cap Blend\n\nstock_sets <- tibble(\n    set_id = c(\"3_sectors\",\n               \"5_sectors\", \n               \"11_sectors\",\n               \"3_sizes\"),\n    \n    description = c(\"3 Sectors picked by GPT-4: Tech, Health, Staples\",\n                    \"5 Sectors picked by GPT-4: above + Energy + Financials\",\n                    \"All  11 Sectors\",\n                    \"Size: Large, Mid, Small--Blend\"),\n    \n    # this is a list column, see https://adv-r.hadley.nz/vectors-chap.html#list-columns \n    symbols = list(sector_3eft_list, sector_5etf_list, sector_11etf_list, size_etfs)\n    )\n\ndate_start <- \"2013-01-01\"\ndate_end   <- \"2023-11-17\"\n```\n:::\n\n\n## Retrieve returns for each periodicity; aka, frequency\n\nFor each SET of tickers, **get_returns** will retrieve log returns for each of three periods:\n\n-   daily\n-   weekly\n-   monthly\n\nThen we will call the get_returns function via map (my favorite function) to create a new list column called **nested_data**. Each row of nested_data *will contain a list* of three dataframes, one for each period. These dataframes will contain the log returns for each ticker in the set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_returns <- function(symbols, start_date, end_date) {\n    mult_stocks <- tq_get(symbols, get = \"stock.prices\", \n                          from = start_date, to = end_date)\n    \n    periods <- c(\"daily\", \"weekly\", \"monthly\")\n    returns_list <- lapply(periods, function(period) {\n        mult_stocks |> \n            group_by(symbol) |> \n            tq_transmute(select = adjusted,\n                         mutate_fun = periodReturn, \n                         period = period, \n                         type = \"log\")\n    })\n    \n    names(returns_list) <- periods\n    return(returns_list)\n}\n\n# Nest return data for each stock set\nstock_sets <- stock_sets |> \n    mutate(nested_data = map(symbols, \n                             ~ get_returns(.x, date_start, date_end)))\n\nprint(stock_sets)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n  set_id     description                                    symbols nested_data \n  <chr>      <chr>                                          <list>  <list>      \n1 3_sectors  3 Sectors picked by GPT-4: Tech, Health, Stap… <chr>   <named list>\n2 5_sectors  5 Sectors picked by GPT-4: above + Energy + F… <chr>   <named list>\n3 11_sectors All  11 Sectors                                <chr>   <named list>\n4 3_sizes    Size: Large, Mid, Small--Blend                 <chr>   <named list>\n```\n:::\n:::\n\n\n## Analyze: add the analysis list column\n\nFor each set and periodicity, the analysis list column generates:\n\n-   vector of volatilities\n-   vector of average returns\n-   correlation matrix (diagonal is 1)\n-   average correlation (as a *rough* measure of diversification)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperform_analysis <- function(data, returns_column) {\n    # Sort the data by symbol and date\n    data_sorted <- data |> arrange(symbol, date)\n    \n    volatilities <- data_sorted |>  \n        group_by(symbol) |>  \n        summarise(volatility = sd(.data[[returns_column]], na.rm = TRUE)) |>  \n        ungroup()\n    \n    avg_returns <- data_sorted |>  \n        group_by(symbol) |>  \n        summarise(avg_return = mean(.data[[returns_column]], na.rm = TRUE)) |>  \n        ungroup()\n    \n    # Pivot to wide format for correlation matrix calculation\n    # Ensuring the data is sorted correctly helps in keeping the order of symbols consistent\n    data_wide <- data_sorted |>  \n        pivot_wider(names_from = symbol, values_from = .data[[returns_column]])\n    corr_matrix <- cor(select(data_wide, -date), use = \"complete.obs\")\n    \n    # Calculate average correlation\n    avg_corr <- mean(corr_matrix[lower.tri(corr_matrix)])\n    \n    return(list(volatilities = volatilities, avg_returns = avg_returns, corr_matrix = corr_matrix, avg_corr = avg_corr))\n}\n\n# Applying the perform_analysis function to the stock_sets\nstock_sets <- stock_sets |> \n    mutate(analysis = map(nested_data, ~ {\n        data_daily <- .x$daily\n        data_weekly <- .x$weekly\n        data_monthly <- .x$monthly\n        \n        analysis_daily <- perform_analysis(data_daily, \"daily.returns\")\n        analysis_weekly <- perform_analysis(data_weekly, \"weekly.returns\")\n        analysis_monthly <- perform_analysis(data_monthly, \"monthly.returns\")\n        \n        list(daily = analysis_daily, weekly = analysis_weekly, monthly = analysis_monthly)\n    }))\n\n# Examine data structure \nprint(stock_sets) # Notice the analysis list column has been added\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  set_id     description                       symbols nested_data  analysis    \n  <chr>      <chr>                             <list>  <list>       <list>      \n1 3_sectors  3 Sectors picked by GPT-4: Tech,… <chr>   <named list> <named list>\n2 5_sectors  5 Sectors picked by GPT-4: above… <chr>   <named list> <named list>\n3 11_sectors All  11 Sectors                   <chr>   <named list> <named list>\n4 3_sizes    Size: Large, Mid, Small--Blend    <chr>   <named list> <named list>\n```\n:::\n\n```{.r .cell-code}\nglimpse(stock_sets)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 4\nColumns: 5\n$ set_id      <chr> \"3_sectors\", \"5_sectors\", \"11_sectors\", \"3_sizes\"\n$ description <chr> \"3 Sectors picked by GPT-4: Tech, Health, Staples\", \"5 Sec…\n$ symbols     <list> <\"XLK\", \"XLV\", \"XLP\">, <\"XLK\", \"XLV\", \"XLP\", \"XLE\", \"XLF\">…\n$ nested_data <list> [[<grouped_df[8217 x 3]>], [<grouped_df[1704 x 3]>], [<gr…\n$ analysis    <list> [[[<tbl_df[3 x 2]>], [<tbl_df[3 x 2]>], <<matrix[3 x 3]>>…\n```\n:::\n\n```{.r .cell-code}\nstock_sets$analysis[[1]] # first row is the first stock set\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$daily\n$daily$volatilities\n# A tibble: 3 × 2\n  symbol volatility\n  <chr>       <dbl>\n1 XLK       0.0138 \n2 XLP       0.00906\n3 XLV       0.0105 \n\n$daily$avg_returns\n# A tibble: 3 × 2\n  symbol avg_return\n  <chr>       <dbl>\n1 XLK      0.000719\n2 XLP      0.000345\n3 XLV      0.000484\n\n$daily$corr_matrix\n          XLK       XLP       XLV\nXLK 1.0000000 0.6357679 0.7254975\nXLP 0.6357679 1.0000000 0.7182656\nXLV 0.7254975 0.7182656 1.0000000\n\n$daily$avg_corr\n[1] 0.693177\n\n\n$weekly\n$weekly$volatilities\n# A tibble: 3 × 2\n  symbol volatility\n  <chr>       <dbl>\n1 XLK        0.0270\n2 XLP        0.0194\n3 XLV        0.0227\n\n$weekly$avg_returns\n# A tibble: 3 × 2\n  symbol avg_return\n  <chr>       <dbl>\n1 XLK       0.00347\n2 XLP       0.00167\n3 XLV       0.00233\n\n$weekly$corr_matrix\n          XLK       XLP       XLV\nXLK 1.0000000 0.6515029 0.6976196\nXLP 0.6515029 1.0000000 0.7046559\nXLV 0.6976196 0.7046559 1.0000000\n\n$weekly$avg_corr\n[1] 0.6845928\n\n\n$monthly\n$monthly$volatilities\n# A tibble: 3 × 2\n  symbol volatility\n  <chr>       <dbl>\n1 XLK        0.0517\n2 XLP        0.0364\n3 XLV        0.0399\n\n$monthly$avg_returns\n# A tibble: 3 × 2\n  symbol avg_return\n  <chr>       <dbl>\n1 XLK       0.0150 \n2 XLP       0.00722\n3 XLV       0.0101 \n\n$monthly$corr_matrix\n          XLK       XLP       XLV\nXLK 1.0000000 0.5679382 0.6136564\nXLP 0.5679382 1.0000000 0.6780580\nXLV 0.6136564 0.6780580 1.0000000\n\n$monthly$avg_corr\n[1] 0.6198842\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecting the desired set (e.g., \"Set 1\")\n\nselect_set <- stock_sets |> \n    filter(set_id == \"11_sectors\") |> \n    pull(\"analysis\")\n\nanalyze_set <- select_set[[1]]\nanalyze_period <- analyze_set$monthly\n\n# Extracting components from the selected set\nexp_returns_period <- analyze_period$avg_returns$avg_return\nnames(exp_returns_period) <- analyze_period$avg_returns$symbol\n\nvolatilities_period <- analyze_period$volatilities$volatility\nnames(volatilities_period) <- analyze_period$volatilities$symbol\n\ncorr_matrix_period <- analyze_period$corr_matrix\nnum_stocks_period <- length(volatilities_period)\n```\n:::\n\n\nCorrelation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggcorrplot)\nlibrary(MASS)\nlibrary(patchwork)\n\ncp1 <- corr_matrix_period |> ggcorrplot(\n    method = \"square\", \n    type = \"lower\", \n    lab = TRUE, \n    colors = c(\"red\", \"white\", \"springgreen\"),\n    title = \"Correlation Matrix of Daily Returns\")\n\ncp1\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nDesirability\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_desirability <- function(exp_returns, volatilities, corr_matrix, A, risk_free_rate, utility_weight, sharpe_weight, correlation_weight) {\n    if(is.null(names(exp_returns)) || is.null(names(volatilities))) {\n        stop(\"Expected returns and volatilities must have names.\")\n    }\n    \n    # Ensure the lengths match\n    if(length(exp_returns) != length(volatilities) || length(exp_returns) != nrow(corr_matrix)) {\n        stop(\"Lengths of returns, volatilities, and correlation matrix do not match.\")\n    }\n    # Ensure the lengths match\n    if(length(exp_returns) != length(volatilities) || length(exp_returns) != nrow(corr_matrix)) {\n        stop(\"Lengths of returns, volatilities, and correlation matrix do not match.\")\n    }\n    \n    # Calculate the variance as the square of volatility\n    variance <- volatilities^2\n    \n    # Calculate the utility for each sector\n    utility <- exp_returns - 0.5 * A * variance\n    \n    # Calculate the Sharpe ratio for each sector\n    sharpe_ratio <- (exp_returns - risk_free_rate) / volatilities\n    \n    # Calculate the average correlation for each sector\n    avg_correlation <- apply(corr_matrix, 1, function(x) mean(x[-which(x == 1)], na.rm = TRUE))\n    write.matrix(corr_matrix, \"avg_correlation.csv\", sep = \",\")\n    \n    # Calculate the desirability score\n    desirability_score <- utility_weight * (utility * 100) +\n        sharpe_weight * (sharpe_ratio * 3 ) -\n        correlation_weight * avg_correlation # Negative because lower correlation is better\n    \n    # Create a data frame for sector desirability\n    desirability_df <- data.frame(sector = names(exp_returns),\n                                  exp_returns = exp_returns,\n                                  volatilities = volatilities,\n                                  utility = utility,\n                                  sharpe_ratio = sharpe_ratio,\n                                  avg_correlation = avg_correlation,\n                                  desirability_score = desirability_score)\n    \n    # Sort by desirability score\n    desirability_df <- desirability_df[order(-desirability_df$desirability_score),]\n    \n    return(desirability_df)\n}\n\n# Example parameters\nA <- 3  # Risk aversion coefficient\nrisk_free_rate <- 0.0  # Risk-free rate\nutility_weight <- 0.3\nsharpe_weight <- 0.4\ncorrelation_weight <- 0.3\n\n# Calculate desirability using the extracted components\nsector_desirability <- calculate_desirability(exp_returns_period, volatilities_period, corr_matrix_period, A, risk_free_rate, utility_weight, sharpe_weight, correlation_weight)\n\nsector_desirability\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     sector exp_returns volatilities       utility sharpe_ratio avg_correlation\nXLK     XLK 0.015025342   0.05165266  0.0110233459   0.29089192       0.6885434\nXLV     XLV 0.010114015   0.03991406  0.0077243160   0.25339477       0.6580335\nXLY     XLY 0.010399520   0.05421595  0.0059904665   0.19181662       0.7084905\nXLP     XLP 0.007222011   0.03642463  0.0052318807   0.19827274       0.6588569\nXLU     XLU 0.007008193   0.04345244  0.0041760216   0.16128423       0.5483552\nXLI     XLI 0.009141406   0.05120984  0.0052077349   0.17850879       0.7663516\nXLF     XLF 0.008677509   0.05444007  0.0042319278   0.15939564       0.7166628\nXLB     XLB 0.007271933   0.05298609  0.0030606447   0.13724231       0.7629429\nXLRE   XLRE 0.004606752   0.05011872  0.0008389219   0.09191678       0.7092791\nXLC     XLC 0.005837405   0.06085228  0.0002829058   0.09592747       0.6907898\nXLE     XLE 0.004030844   0.08350624 -0.0064290935   0.04826997       0.5421771\n     desirability_score\nXLK          0.47320766\nXLV          0.33839315\nXLY          0.19734680\nXLP          0.19722663\nXLU          0.15431518\nXLI          0.14053713\nXLF          0.10323376\nXLB          0.02762725\nXLRE        -0.07731594\nXLC         -0.08363680\nXLE         -0.29760195\n```\n:::\n:::\n\n\n## Setup the simulation\n\nThe **get_random_weights** function returns a dataframe of random weights. Each column is a set of weights for a single simulation. Each row is the weight for a single stock. The weights are normalized so that they sum to 1.\n\nSo I'm starting with an incredibly naive approach to the simulation. I'm going to assume that the expected return for each stock is the average return for that stock over the entire period. I'm also going to assume that the volatility for each stock is the average volatility for that stock over the entire period. *Most importantly*, the only randomness in the simulation is the weights and they are totally naive because they are independent of the analysis. We can't expect anything like an efficient frontier from the raw scatterplot. However, this will illustrate the future risk/reward trade-off faced by a \"totally naive\" investor!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# returns a data frame of random weights\n# rows = weight per stock; columns = number of simulations\nget_random_weights <- function(num_stocks, num_simulations, probabilities) {\n    set.seed(123)\n    weights_df <- matrix(nrow = num_stocks, ncol = num_simulations)\n\n    for (i in 1:num_simulations) {\n        # Generate weights influenced by probabilities\n        weights <- runif(num_stocks) * probabilities\n        weights_df[, i] <- weights / sum(weights)  # Normalize the weights\n    }\n\n    return(as.data.frame(weights_df))\n}\n\n# single simulation: given a set of weights, computes the expected return and volatility\nport_sim <- function(exp_returns, volatilities, corr_matrix, weights) {\n    \n    cov_matrix <- outer(volatilities, volatilities) * corr_matrix\n    port_variance <- t(weights) %*% cov_matrix %*% weights\n    port_exp_return <- sum(weights * exp_returns)\n\n    return(list(exp_returns = exp_returns, \n                volatilities = volatilities,\n                cov_matrix = cov_matrix, \n                corr_matrix = corr_matrix,\n                port_variance = port_variance,\n                port_exp_return = port_exp_return))\n}\n\n# runs a port_simulation for each column in the weights_df\nrun_sims <- function(exp_returns, volatilities, corr_matrix, weights_df) {\n    simulations <- map(1:ncol(weights_df), ~ {\n        weights_vector <- weights_df[, .x]\n        port_sim(exp_returns, volatilities, corr_matrix, weights_vector)\n        })\n    \n    return(simulations)\n}\n```\n:::\n\n\n## Run the simulation (on a single set)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_sims <- 10000  # Set the number of simulations\n\nsector_desirability$desirability_score <- pmax(sector_desirability$desirability_score, 0)\ntotal_score <- sum(sector_desirability$desirability_score)\nprobabilities <- sector_desirability$desirability_score / total_score\n\n\nrandom_weights_df_period <- get_random_weights(num_stocks_period, num_sims, probabilities)\nsim_results_period <- run_sims(exp_returns_period, \n                              volatilities_period, \n                              corr_matrix_period, \n                              random_weights_df_period)\n\n# Print results of the first simulation\nprint(sim_results_period[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$exp_returns\n        XLB         XLC         XLE         XLF         XLI         XLK \n0.007271933 0.005837405 0.004030844 0.008677509 0.009141406 0.015025342 \n        XLP        XLRE         XLU         XLV         XLY \n0.007222011 0.004606752 0.007008193 0.010114015 0.010399520 \n\n$volatilities\n       XLB        XLC        XLE        XLF        XLI        XLK        XLP \n0.05298609 0.06085228 0.08350624 0.05444007 0.05120984 0.05165266 0.03642463 \n      XLRE        XLU        XLV        XLY \n0.05011872 0.04345244 0.03991406 0.05421595 \n\n$cov_matrix\n             XLB         XLC         XLE         XLF         XLI         XLK\nXLB  0.002807526 0.002445591 0.002939209 0.002453076 0.002449652 0.002039863\nXLC  0.002445591 0.003703000 0.002729728 0.002525212 0.002395695 0.002707615\nXLE  0.002939209 0.002729728 0.006973292 0.003519155 0.002980982 0.002003833\nXLF  0.002453076 0.002525212 0.003519155 0.002963721 0.002500637 0.001908759\nXLI  0.002449652 0.002395695 0.002980982 0.002500637 0.002622447 0.002071542\nXLK  0.002039863 0.002707615 0.002003833 0.001908759 0.002071542 0.002667998\nXLP  0.001440331 0.001273703 0.001455723 0.001279402 0.001394055 0.001159082\nXLRE 0.002086998 0.002209362 0.001960762 0.001904553 0.001926469 0.001842359\nXLU  0.001410705 0.001306091 0.001132947 0.001157953 0.001280432 0.001077269\nXLV  0.001605595 0.001455557 0.001672473 0.001400932 0.001527509 0.001348071\nXLY  0.002309809 0.002730008 0.002369834 0.002144644 0.002204521 0.002493967\n             XLP        XLRE         XLU         XLV         XLY\nXLB  0.001440331 0.002086998 0.001410705 0.001605595 0.002309809\nXLC  0.001273703 0.002209362 0.001306091 0.001455557 0.002730008\nXLE  0.001455723 0.001960762 0.001132947 0.001672473 0.002369834\nXLF  0.001279402 0.001904553 0.001157953 0.001400932 0.002144644\nXLI  0.001394055 0.001926469 0.001280432 0.001527509 0.002204521\nXLK  0.001159082 0.001842359 0.001077269 0.001348071 0.002493967\nXLP  0.001326754 0.001352455 0.001134192 0.001080211 0.001145343\nXLRE 0.001352455 0.002511886 0.001581032 0.001387531 0.002155425\nXLU  0.001134192 0.001581032 0.001888114 0.001013965 0.001160315\nXLV  0.001080211 0.001387531 0.001013965 0.001593132 0.001412943\nXLY  0.001145343 0.002155425 0.001160315 0.001412943 0.002939369\n\n$corr_matrix\n           XLB       XLC       XLE       XLF       XLI       XLK       XLP\nXLB  1.0000000 0.7584819 0.6642778 0.8504140 0.9027950 0.7453263 0.7462862\nXLC  0.7584819 1.0000000 0.5371847 0.7622585 0.7687785 0.8614248 0.5746405\nXLE  0.6642778 0.5371847 1.0000000 0.7741067 0.6970871 0.4645686 0.4785911\nXLF  0.8504140 0.7622585 0.7741067 1.0000000 0.8969715 0.6787967 0.6451982\nXLI  0.9027950 0.7687785 0.6970871 0.8969715 1.0000000 0.7831547 0.7473627\nXLK  0.7453263 0.8614248 0.4645686 0.6787967 0.7831547 1.0000000 0.6160648\nXLP  0.7462862 0.5746405 0.4785911 0.6451982 0.7473627 0.6160648 1.0000000\nXLRE 0.7858870 0.7244194 0.4684961 0.6980305 0.7506003 0.7116746 0.7408458\nXLU  0.6127171 0.4939495 0.3122313 0.4895063 0.5754254 0.4799737 0.7166010\nXLV  0.7591859 0.5992755 0.5017812 0.6447219 0.7473162 0.6538742 0.7429981\nXLY  0.8040577 0.8274848 0.5234461 0.7266236 0.7940243 0.8905759 0.5799807\n          XLRE       XLU       XLV       XLY\nXLB  0.7858870 0.6127171 0.7591859 0.8040577\nXLC  0.7244194 0.4939495 0.5992755 0.8274848\nXLE  0.4684961 0.3122313 0.5017812 0.5234461\nXLF  0.6980305 0.4895063 0.6447219 0.7266236\nXLI  0.7506003 0.5754254 0.7473162 0.7940243\nXLK  0.7116746 0.4799737 0.6538742 0.8905759\nXLP  0.7408458 0.7166010 0.7429981 0.5799807\nXLRE 1.0000000 0.7259829 0.6936121 0.7932422\nXLU  0.7259829 1.0000000 0.5846324 0.4925322\nXLV  0.6936121 0.5846324 1.0000000 0.6529376\nXLY  0.7932422 0.4925322 0.6529376 1.0000000\n\n$port_variance\n            [,1]\n[1,] 0.002567196\n\n$port_exp_return\n[1] 0.007106525\n```\n:::\n\n```{.r .cell-code}\nresults_df_period <- map_dfr(sim_results_period, ~ data.frame(Exp_Return = .x$port_exp_return, \n                                                            Std_Dev = sqrt(.x$port_variance)))\n# View summarized results for daily returns\nprint(head(results_df_period))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Exp_Return    Std_Dev\n1 0.007106525 0.05066750\n2 0.007058208 0.05249469\n3 0.007349765 0.05167136\n4 0.007666882 0.05147461\n5 0.009318553 0.04969520\n6 0.008069111 0.05307626\n```\n:::\n\n```{.r .cell-code}\nresults_df <- results_df_period\n```\n:::\n\n\n## Visualize the results\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork)\n\nresults_df <- results_df |> \n    arrange(Std_Dev) |> \n    mutate(is_efficient = Exp_Return >= cummax(Exp_Return))\n\nefficient_portfolios <- results_df |> \n    arrange(Std_Dev)  |> \n    mutate(cummax_return = cummax(Exp_Return)) |> \n    filter(Exp_Return >= cummax_return)\n\nefficient_model <- lm(Exp_Return ~ poly(Std_Dev, 2), data = efficient_portfolios)\n\np1 <- ggplot(results_df, aes(x = Std_Dev, y = Exp_Return, color = is_efficient)) +\n    geom_point() +\n    scale_color_manual(values = c(\"azure2\", \"springgreen4\")) + \n    theme_minimal() +\n    theme(\n        axis.title = element_blank(),\n        legend.position = \"none\"\n    )\n\np2 <- ggplot(results_df, aes(x = Std_Dev, y = Exp_Return)) +\n    geom_point(aes(color = is_efficient), size = 1) +  # Default size for all points\n    geom_point(data = filter(results_df, is_efficient), \n               aes(color = is_efficient), size = 2) +  # Larger size for efficient points\n    scale_color_manual(values = c(\"azure2\", \"springgreen4\")) +\n    theme_minimal() +\n    geom_line(data = efficient_portfolios, aes(x = Std_Dev, y = Exp_Return), colour = \"springgreen2\") +\n    theme(\n        axis.title = element_blank(),\n        legend.position = \"none\"\n    )\n\np3 <- ggplot(results_df, aes(x = Std_Dev, y = Exp_Return)) +\n    geom_point(color = \"azure2\") +\n    geom_smooth(data = efficient_portfolios, method = \"lm\", formula = y ~ poly(x, 2), \n                se = FALSE, colour = \"springgreen4\", linewidth = 1.5) +\n    labs(x = \"Std Dev (Risk)\",\n         y = \"Return\") +\n    theme_minimal()\n\n# Calculate a color metric based on Exp_Return and Std_Dev\n\nRiskFree_temp <- 0.0\nresults_df <- results_df %>%\n    mutate(efficiency = (Exp_Return - RiskFree_temp)/ Std_Dev)\n\n# Create a scatterplot with color gradient based on the color_metric\n# p4 <- ggplot(results_df, aes(x = Std_Dev, y = Exp_Return, color = color_metric)) +\n#     geom_point() +\n#     scale_color_gradient2(low = \"azure3\", high = \"springgreen1\", mid = \"yellow\", \n#                           midpoint = median(results_df$color_metric)) +\n#     theme_minimal() +\n#     labs(color = \"Color Metric\")\n\n# Assuming results_df and color_metric are already defined appropriately\n\np4 <- ggplot(results_df, aes(x = Std_Dev, y = Exp_Return, color = efficiency)) +\n    geom_point() +\n    scale_color_gradientn(colors = c(\"azure4\", \"lightgoldenrod1\", \"springgreen2\"),\n                          values = scales::rescale(c(min(results_df$efficiency), \n                                                     max(results_df$efficiency)))) +\n    theme_minimal() +\n    labs(x = \"Std Dev (Risk)\",\n         y = \"Return\", \n         color = \"efficiency\") \n\n(p1 + p2) / (p3 + p4 )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}