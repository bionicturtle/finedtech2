{
  "hash": "f443e44d76ff9fe8c29d664c9af68e2a",
  "result": {
    "markdown": "---\ntitle: Portfolio Possibilities Curve (PPC)\ndescription: PPC with GPT4 as my coding partner\nauthor: David Harper, CFA, FRM\ndate: 2023-11-19\ncategories: [code, analysis]\nexecute: \n  echo: true\n  warning: false\n---\n\n\nContents\n\n-   Define the sets of stocks/indices\n-   Retrieve returns for each periodicity\n-   Analyze: add the analysis list column\n-   Setup the simulation\n-   Run the simulation\n-   Visualize\n\nload libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidyquant)\n# library(dplyr); library(tidyr); library(purrr)\n# library(ggplot)\n```\n:::\n\n\n## Define the SETS of stocks/indices\n\nThe container in this approach is **stock_sets**, a dataframe the we initialize (our TOC) with three columns:\n\n-   set_id\n-   description\n-   symbols: a list of tickers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsector_3eft_list <- c( \"XLK\", \"XLV\", \"XLP\") # Tech, Health, Staples\n# sector_4etf_list <- c( \"XLK\", \"XLV\", \"XLP\",  \"XLE\",) # Tech, Health, Staples, Energy\nsector_5etf_list <- c( \"XLK\", \"XLV\", \"XLP\", \"XLE\", \"XLF\") # Tech, Health, Staples, Energy, Financials\n# sector_7etf_list <- c(sector_5etf_list, \"XLI\", \"XLU\")\nsector_11etf_list <- c(\"XLK\",  # Technology\n                      \"XLV\",  # Health Care\n                      \"XLF\",  # Financials\n                      \"XLY\",  # Consumer Discretionary\n                      \"XLP\",  # Consumer Staples\n                      \"XLE\",  # Energy\n                      \"XLU\",  # Utilities\n                      \"XLI\",  # Industrials\n                      \"XLB\",  # Materials\n                      \"XLRE\", # Real Estate\n                      \"XLC\") # Communication Services\n\nsize_etfs <- c(\"SPY\", \"MDY\", \"IWM\") # Large, Mid, Small\n# size_style_etfs <- c(\"IWF\",  # Large-Cap Growth\n#                      \"IWD\",  # Large-Cap Value\n#                      \"SPY\",  # Large-Cap Blend\n#                      \"IWP\",  # Mid-Cap Growth\n#                      \"IWS\",  # Mid-Cap Value\n#                      \"MDY\",  # Mid-Cap Blend\n#                      \"IWO\",  # Small-Cap Growth\n#                      \"IWN\",  # Small-Cap Value\n#                      \"IWM\")  # Small-Cap Blend\n\nstock_sets <- tibble(\n    set_id = c(\"3_sectors\",\n               \"5_sectors\", \n               \"11_sectors\",\n               \"3_sizes\"),\n    \n    description = c(\"3 Sectors picked by GPT-4: Tech, Health, Staples\",\n                    \"5 Sectors picked by GPT-4: above + Energy + Financials\",\n                    \"All  11 Sectors\",\n                    \"Size: Large, Mid, Small--Blend\"),\n    \n    # this is a list column, see https://adv-r.hadley.nz/vectors-chap.html#list-columns \n    symbols = list(sector_3eft_list, sector_5etf_list, sector_11etf_list, size_etfs)\n    )\n\ndate_start <- \"2013-01-01\"\ndate_end   <- \"2023-11-17\"\n```\n:::\n\n\n## Retrieve returns for each periodicity; aka, frequency\n\nFor each SET of tickers, **get_returns** will retrieve log returns for each of three periods:\n\n-   daily\n-   weekly\n-   monthly\n\nThen we will call the get_returns function via map (my favorite function) to create a new list column called **nested_data**. Each row of nested_data *will contain a list* of three dataframes, one for each period. These dataframes will contain the log returns for each ticker in the set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_returns <- function(symbols, start_date, end_date) {\n    mult_stocks <- tq_get(symbols, get = \"stock.prices\", \n                          from = start_date, to = end_date)\n    \n    periods <- c(\"daily\", \"weekly\", \"monthly\")\n    returns_list <- lapply(periods, function(period) {\n        mult_stocks |> \n            group_by(symbol) |> \n            tq_transmute(select = adjusted,\n                         mutate_fun = periodReturn, \n                         period = period, \n                         type = \"log\")\n    })\n    \n    names(returns_list) <- periods\n    return(returns_list)\n}\n\n# Nest return data for each stock set\nstock_sets <- stock_sets |> \n    mutate(nested_data = map(symbols, \n                             ~ get_returns(.x, date_start, date_end)))\n\nprint(stock_sets)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n  set_id     description                                    symbols nested_data \n  <chr>      <chr>                                          <list>  <list>      \n1 3_sectors  3 Sectors picked by GPT-4: Tech, Health, Stap… <chr>   <named list>\n2 5_sectors  5 Sectors picked by GPT-4: above + Energy + F… <chr>   <named list>\n3 11_sectors All  11 Sectors                                <chr>   <named list>\n4 3_sizes    Size: Large, Mid, Small--Blend                 <chr>   <named list>\n```\n:::\n:::\n\n\n## Analyze: add the analysis list column\n\nFor each set and periodicity, the analysis list column generates:\n\n-   vector of volatilities\n-   vector of average returns\n-   correlation matrix (diagonal is 1)\n-   average correlation (as a *rough* measure of diversification)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperform_analysis <- function(data, returns_column) {\n    volatilities <- data |>  \n        group_by(symbol) |>  \n        summarise(volatility = sd(.data[[returns_column]], na.rm = TRUE)) |>  \n        ungroup()\n    \n    avg_returns <- data |>  \n        group_by(symbol) |>  \n        summarise(avg_return = mean(.data[[returns_column]], na.rm = TRUE)) |>  \n        ungroup()\n    \n    data_wide <- data |>  \n        pivot_wider(names_from = symbol, values_from = .data[[returns_column]])\n    corr_matrix <- cor(select(data_wide, -date), use = \"complete.obs\")\n    avg_corr <- mean(corr_matrix[lower.tri(corr_matrix)])\n    \n    return(list(volatilities = volatilities, avg_returns = avg_returns, corr_matrix = corr_matrix, avg_corr = avg_corr))\n}\n\n# Applying the perform_analysis function to the stock_sets\nstock_sets <- stock_sets |> \n    mutate(analysis = map(nested_data, ~ {\n        data_daily <- .x$daily\n        data_weekly <- .x$weekly\n        data_monthly <- .x$monthly\n        \n        analysis_daily <- perform_analysis(data_daily, \"daily.returns\")\n        analysis_weekly <- perform_analysis(data_weekly, \"weekly.returns\")\n        analysis_monthly <- perform_analysis(data_monthly, \"monthly.returns\")\n        \n        list(daily = analysis_daily, weekly = analysis_weekly, monthly = analysis_monthly)\n    }))\n\n# Examine data structure \nprint(stock_sets) # Notice the analysis list column has been added\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  set_id     description                       symbols nested_data  analysis    \n  <chr>      <chr>                             <list>  <list>       <list>      \n1 3_sectors  3 Sectors picked by GPT-4: Tech,… <chr>   <named list> <named list>\n2 5_sectors  5 Sectors picked by GPT-4: above… <chr>   <named list> <named list>\n3 11_sectors All  11 Sectors                   <chr>   <named list> <named list>\n4 3_sizes    Size: Large, Mid, Small--Blend    <chr>   <named list> <named list>\n```\n:::\n\n```{.r .cell-code}\nglimpse(stock_sets)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 4\nColumns: 5\n$ set_id      <chr> \"3_sectors\", \"5_sectors\", \"11_sectors\", \"3_sizes\"\n$ description <chr> \"3 Sectors picked by GPT-4: Tech, Health, Staples\", \"5 Sec…\n$ symbols     <list> <\"XLK\", \"XLV\", \"XLP\">, <\"XLK\", \"XLV\", \"XLP\", \"XLE\", \"XLF\">…\n$ nested_data <list> [[<grouped_df[8217 x 3]>], [<grouped_df[1704 x 3]>], [<gr…\n$ analysis    <list> [[[<tbl_df[3 x 2]>], [<tbl_df[3 x 2]>], <<matrix[3 x 3]>>…\n```\n:::\n\n```{.r .cell-code}\nstock_sets$analysis[[1]] # first row is the first stock set\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$daily\n$daily$volatilities\n# A tibble: 3 × 2\n  symbol volatility\n  <chr>       <dbl>\n1 XLK       0.0138 \n2 XLP       0.00906\n3 XLV       0.0105 \n\n$daily$avg_returns\n# A tibble: 3 × 2\n  symbol avg_return\n  <chr>       <dbl>\n1 XLK      0.000719\n2 XLP      0.000345\n3 XLV      0.000484\n\n$daily$corr_matrix\n          XLK       XLV       XLP\nXLK 1.0000000 0.7254977 0.6357681\nXLV 0.7254977 1.0000000 0.7182649\nXLP 0.6357681 0.7182649 1.0000000\n\n$daily$avg_corr\n[1] 0.6931769\n\n\n$weekly\n$weekly$volatilities\n# A tibble: 3 × 2\n  symbol volatility\n  <chr>       <dbl>\n1 XLK        0.0270\n2 XLP        0.0194\n3 XLV        0.0227\n\n$weekly$avg_returns\n# A tibble: 3 × 2\n  symbol avg_return\n  <chr>       <dbl>\n1 XLK       0.00347\n2 XLP       0.00167\n3 XLV       0.00233\n\n$weekly$corr_matrix\n          XLK       XLV       XLP\nXLK 1.0000000 0.6976196 0.6515028\nXLV 0.6976196 1.0000000 0.7046562\nXLP 0.6515028 0.7046562 1.0000000\n\n$weekly$avg_corr\n[1] 0.6845929\n\n\n$monthly\n$monthly$volatilities\n# A tibble: 3 × 2\n  symbol volatility\n  <chr>       <dbl>\n1 XLK        0.0517\n2 XLP        0.0364\n3 XLV        0.0399\n\n$monthly$avg_returns\n# A tibble: 3 × 2\n  symbol avg_return\n  <chr>       <dbl>\n1 XLK       0.0150 \n2 XLP       0.00722\n3 XLV       0.0101 \n\n$monthly$corr_matrix\n          XLK       XLV       XLP\nXLK 1.0000000 0.6136564 0.5679385\nXLV 0.6136564 1.0000000 0.6780583\nXLP 0.5679385 0.6780583 1.0000000\n\n$monthly$avg_corr\n[1] 0.6198844\n```\n:::\n:::\n\n\nHere is a class diagram of the stock_sets data structure rendered by [DiagrammeR via Graphviz](https://graphviz.org/Gallery/directed/UML_Class_diagram.html).\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div class=\"grViz html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-c5d41eb0228d4f0af9ad\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-c5d41eb0228d4f0af9ad\">{\"x\":{\"diagram\":\"\\ndigraph stock_sets_structure {\\n    graph [splines=ortho]\\n    \\n    node [shape=record]\\n    \\n    stock_sets [label=\\\"{stock_sets|+ set_id : String\\\\l+ description : String\\\\l+ symbols : List\\\\l+ nested_data : List\\\\l+ analysis : List\\\\l}\\\"]\\n\\n    nested_data [label=\\\"{nested_data|+ daily : DataFrame\\\\l+ weekly : DataFrame\\\\l+ monthly : DataFrame\\\\l}\\\"]\\n\\n    analysis [label=\\\"{analysis|+ daily_analysis : List\\\\l+ weekly_analysis : List\\\\l+ monthly_analysis : List\\\\l}\\\"]\\n\\n    daily_analysis [label=\\\"{daily_analysis|+ volatilities : DataFrame\\\\l+ avg_returns : DataFrame\\\\l+ corr_matrix : Matrix\\\\l+ avg_corr : Numeric\\\\l}\\\"]\\n\\n    weekly_analysis [label=\\\"{weekly_analysis|+ volatilities : DataFrame\\\\l+ avg_returns : DataFrame\\\\l+ corr_matrix : Matrix\\\\l+ avg_corr : Numeric\\\\l}\\\"]\\n\\n    monthly_analysis [label=\\\"{monthly_analysis|+ volatilities : DataFrame\\\\l+ avg_returns : DataFrame\\\\l+ corr_matrix : Matrix\\\\l+ avg_corr : Numeric\\\\l}\\\"]\\n\\n    stock_sets -> nested_data\\n    stock_sets -> analysis\\n    analysis -> daily_analysis\\n    analysis -> weekly_analysis\\n    analysis -> monthly_analysis\\n}\\n\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n## Setup the simulation\n\nThe **get_random_weights** function returns a dataframe of random weights. Each column is a set of weights for a single simulation. Each row is the weight for a single stock. The weights are normalized so that they sum to 1.\n\nSo I'm starting with an incredibly naive approach to the simulation. I'm going to assume that the expected return for each stock is the average return for that stock over the entire period. I'm also going to assume that the volatility for each stock is the average volatility for that stock over the entire period. *Most importantly*, the only randomness in the simulation is the weights and they are totally naive because they are independent of the analysis. We can't expect anything like an efficient frontier from the raw scatterplot. However, this will illustrate the future risk/reward trade-off faced by a \"totally naive\" investor!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# returns a data frame of random weights\n# rows = weight per stock; columns = number of simulations\nget_random_weights <- function(num_stocks, num_simulations) {\n    set.seed(123)\n    weights_df <- matrix(nrow = num_stocks, ncol = num_simulations)\n\n    for (i in 1:num_simulations) {\n        weights <- runif(num_stocks)\n        weights_df[, i] <- weights / sum(weights)\n    }\n\n    return(as.data.frame(weights_df))\n}\n\n# single simulation: given a set of weights, computes the expected return and volatility\nport_sim <- function(exp_returns, volatilities, corr_matrix, weights) {\n    \n    cov_matrix <- outer(volatilities, volatilities) * corr_matrix\n    port_variance <- t(weights) %*% cov_matrix %*% weights\n    port_exp_return <- sum(weights * exp_returns)\n\n    return(list(exp_returns = exp_returns, \n                volatilities = volatilities,\n                cov_matrix = cov_matrix, \n                corr_matrix = corr_matrix,\n                port_variance = port_variance,\n                port_exp_return = port_exp_return))\n}\n\n# runs a port_simulation for each column in the weights_df\nrun_sims <- function(exp_returns, volatilities, corr_matrix, weights_df) {\n    simulations <- map(1:ncol(weights_df), ~ {\n        weights_vector <- weights_df[, .x]\n        port_sim(exp_returns, volatilities, corr_matrix, weights_vector)\n        })\n    \n    return(simulations)\n}\n```\n:::\n\n\n## Run the simulation (on a single set)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecting the desired set (e.g., \"Set 1\")\nselect_set <- stock_sets |> \n    filter(set_id == \"5_sectors\") |> \n    pull(\"analysis\")\n\nanalyze_set <- select_set[[1]]\nanalyze_period <- analyze_set$monthly\n\n# Extracting components from the selected set\nexp_returns_period <- analyze_period$avg_returns$avg_return\nvolatilities_period <- analyze_period$volatilities$volatility\ncorr_matrix_period <- analyze_period$corr_matrix\nnum_stocks_period <- length(volatilities_period)\n\nnum_sims <- 20000  # Set the number of simulations\nrandom_weights_df_period <- get_random_weights(num_stocks_period, num_sims)\nsim_results_period <- run_sims(exp_returns_period, \n                              volatilities_period, \n                              corr_matrix_period, \n                              random_weights_df_period)\n\n# Print results of the first simulation\nprint(sim_results_period[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$exp_returns\n[1] 0.004030846 0.008677509 0.015025342 0.007222011 0.010114014\n\n$volatilities\n[1] 0.08350623 0.05444006 0.05165270 0.03642462 0.03991410\n\n$cov_matrix\n            XLK          XLV          XLP          XLE         XLF\nXLK 0.006973290 0.0027897366 0.0024497012 0.0013125262 0.002137823\nXLV 0.002789737 0.0029637200 0.0019066845 0.0008771254 0.001387132\nXLP 0.002449701 0.0019066845 0.0026680010 0.0007372934 0.001139679\nXLE 0.001312526 0.0008771254 0.0007372934 0.0013267528 0.001034452\nXLF 0.002137823 0.0013871321 0.0011396791 0.0010344519 0.001593135\n\n$corr_matrix\n          XLK       XLV       XLP       XLE       XLF\nXLK 1.0000000 0.6136571 0.5679384 0.4315132 0.6413965\nXLV 0.6136571 1.0000000 0.6780586 0.4423317 0.6383707\nXLP 0.5679384 0.6780586 1.0000000 0.3918793 0.5527939\nXLE 0.4315132 0.4423317 0.3918793 1.0000000 0.7115231\nXLF 0.6413965 0.6383707 0.5527939 0.7115231 1.0000000\n\n$port_variance\n            [,1]\n[1,] 0.001517294\n\n$port_exp_return\n[1] 0.009078192\n```\n:::\n\n```{.r .cell-code}\nresults_df_period <- map_dfr(sim_results_period, ~ data.frame(Exp_Return = .x$port_exp_return, \n                                                            Std_Dev = sqrt(.x$port_variance)))\n# View summarized results for daily returns\nprint(head(results_df_period))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Exp_Return    Std_Dev\n1 0.009078192 0.03895245\n2 0.010822326 0.03906639\n3 0.008376929 0.04953396\n4 0.007454897 0.04938544\n5 0.008529608 0.04357777\n6 0.008795629 0.04981343\n```\n:::\n\n```{.r .cell-code}\nresults_df <- results_df_period\n```\n:::\n\n\n## Visualize the results\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork)\n\nresults_df <- results_df |> \n    arrange(Std_Dev) |> \n    mutate(is_efficient = Exp_Return >= cummax(Exp_Return))\n\nefficient_portfolios <- results_df |> \n    arrange(Std_Dev)  |> \n    mutate(cummax_return = cummax(Exp_Return)) |> \n    filter(Exp_Return >= cummax_return)\n\nefficient_model <- lm(Exp_Return ~ poly(Std_Dev, 2), data = efficient_portfolios)\n\np1 <- ggplot(results_df, aes(x = Std_Dev, y = Exp_Return, color = is_efficient)) +\n    geom_point() +\n    scale_color_manual(values = c(\"azure2\", \"springgreen4\")) + \n    theme_minimal() +\n    theme(\n        axis.title = element_blank(),\n        legend.position = \"none\"\n    )\n\np2 <- ggplot(results_df, aes(x = Std_Dev, y = Exp_Return)) +\n    geom_point(aes(color = is_efficient), size = 1) +  # Default size for all points\n    geom_point(data = filter(results_df, is_efficient), \n               aes(color = is_efficient), size = 2) +  # Larger size for efficient points\n    scale_color_manual(values = c(\"azure2\", \"springgreen4\")) +\n    theme_minimal() +\n    geom_line(data = efficient_portfolios, aes(x = Std_Dev, y = Exp_Return), colour = \"springgreen2\") +\n    theme(\n        axis.title = element_blank(),\n        legend.position = \"none\"\n    )\n\np3 <- ggplot(results_df, aes(x = Std_Dev, y = Exp_Return)) +\n    geom_point(color = \"azure2\") +\n    geom_smooth(data = efficient_portfolios, method = \"lm\", formula = y ~ poly(x, 2), \n                se = FALSE, colour = \"springgreen4\", linewidth = 1.5) +\n    labs(x = \"Std Dev (Risk)\",\n         y = \"Return\") +\n    theme_minimal()\n\n# Calculate a color metric based on Exp_Return and Std_Dev\n\nRiskFree_temp <- 0.0\nresults_df <- results_df %>%\n    mutate(efficiency = (Exp_Return - RiskFree_temp)/ Std_Dev)\n\n# Create a scatterplot with color gradient based on the color_metric\n# p4 <- ggplot(results_df, aes(x = Std_Dev, y = Exp_Return, color = color_metric)) +\n#     geom_point() +\n#     scale_color_gradient2(low = \"azure3\", high = \"springgreen1\", mid = \"yellow\", \n#                           midpoint = median(results_df$color_metric)) +\n#     theme_minimal() +\n#     labs(color = \"Color Metric\")\n\n# Assuming results_df and color_metric are already defined appropriately\n\np4 <- ggplot(results_df, aes(x = Std_Dev, y = Exp_Return, color = efficiency)) +\n    geom_point() +\n    scale_color_gradientn(colors = c(\"azure4\", \"lightgoldenrod1\", \"springgreen2\"),\n                          values = scales::rescale(c(min(results_df$efficiency), \n                                                     max(results_df$efficiency)))) +\n    theme_minimal() +\n    labs(x = \"Std Dev (Risk)\",\n         y = \"Return\", \n         color = \"efficiency\") \n\n(p1 + p2) / (p3 + p4 )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\r\n<script src=\"../../site_libs/viz-1.8.2/viz.js\"></script>\r\n<link href=\"../../site_libs/DiagrammeR-styles-0.2/styles.css\" rel=\"stylesheet\" />\r\n<script src=\"../../site_libs/grViz-binding-1.0.10.9000/grViz.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}